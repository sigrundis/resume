{"version":3,"file":"index.esm.js","sources":["../src/index.ts"],"sourcesContent":["export interface Options {\n  viewport: null | Element\n  modTop: string\n  modRight: string\n  modBottom: string\n  modLeft: string\n  threshold: number | number[]\n}\n\nexport interface CustomEntry extends IntersectionObserverEntry {\n  isInViewport?: boolean\n}\n\nexport type UnobserveFn = () => void\n\nexport type Handler = (entry: CustomEntry, unobserveFn: UnobserveFn, el: Element) => any\n\n/**\n * Given a set of options, DOM node and in and out of viewport handlers,\n * this function uses an IntersectionObserver to figure out whether\n * the DOM node is in viewport or not and calls the respective handler.\n * It is a curried function and expects the parameters in the not so\n * common order so as to make it easier to observe multiple DOM nodes\n * with the same settings/options and maybe even the same handlers.\n *\n * @param {Node} target - target element to observe\n * and intersection threshold\n * @param {function} inHandler - fn to call when element is in viewport\n * for each given threshhold\n * @param {function} outHandler - fn to call when element leaves viewport\n * @param {object} opts - options to configure the viewport\n *\n * @return {function} unobserve element function\n */\nexport function observeElementInViewport(\n  target: Element | null,\n  inHandler: Handler,\n  outHandler: Handler = () => undefined,\n  opts: Partial<Options> = {}\n): UnobserveFn {\n  const defaultOptions: Options = {\n    // null for window, otherwise give css selector.\n    // el to be observed should be a child of element given by this selector\n    viewport: null,\n\n    // accepts px and %\n    modTop: '0px',\n    modRight: '0px',\n    modBottom: '0px',\n    modLeft: '0px',\n\n    // percentage of el that should intersect with viewport to consinder\n    // it \"in viewport\". 0 means on the 1st pixel intersection or exit,\n    // the respective handler will be called\n    threshold: [0]\n  }\n\n  if (!target) {\n    throw new Error('Target element to observe should be a valid DOM Node')\n  }\n\n  const { viewport, modTop, modLeft, modBottom, modRight, threshold }: Options = Object.assign(\n    {},\n    defaultOptions,\n    opts\n  )\n\n  if (!Array.isArray(threshold) && !(typeof threshold === 'number')) {\n    throw new Error('threshold should be a number or an array of numbers')\n  }\n\n  // The mod 101 is to prevent threshold from being greater than 1\n  const thresholdArray: number[] = Array.isArray(threshold)\n    ? threshold.map(t => Math.floor(t % 101) / 100)\n    : [Math.floor(threshold ? threshold % 101 : 0) / 100]\n\n  const minThreshold: number = Math.min(...thresholdArray)\n\n  const intersectionObserverOptions: IntersectionObserverInit = {\n    root: viewport instanceof Node ? viewport : null,\n    rootMargin: `${modTop} ${modRight} ${modBottom} ${modLeft}`,\n    threshold: thresholdArray\n  }\n\n  const cb = (entries: IntersectionObserverEntry[], observer: IntersectionObserver): void => {\n    const entryForEl: CustomEntry = entries.filter(entry => entry.target === target)[0]\n    const unobserve: UnobserveFn = () => observer.unobserve(target)\n\n    if (entryForEl) {\n      const { isIntersecting, intersectionRatio } = entryForEl\n\n      entryForEl.isInViewport = isIntersecting && intersectionRatio >= minThreshold\n\n      if (entryForEl.isInViewport) {\n        inHandler(entryForEl, unobserve, target)\n      } else {\n        outHandler(entryForEl, unobserve, target)\n      }\n    }\n  }\n\n  const intersectionObserver = new IntersectionObserver(cb, intersectionObserverOptions)\n\n  intersectionObserver.observe(target)\n\n  return () => intersectionObserver.unobserve(target)\n}\n\n// The function can return Promise that resolves to boolean or an object since in JS\n// anything can be thrown thus we cannot not know what we reject with in the catch block\nexport const isInViewport = (\n  el: Element | null,\n  opts: Partial<Options> = {}\n): Promise<boolean | {}> => {\n  return new Promise((resolve, reject) => {\n    try {\n      observeElementInViewport(\n        el,\n        (_, unobserve) => {\n          unobserve()\n          resolve(true)\n        },\n        (_, unobserve) => {\n          unobserve()\n          resolve(false)\n        },\n        opts\n      )\n    } catch (e) {\n      reject(e)\n    }\n  })\n}\n"],"names":["observeElementInViewport","target","inHandler","outHandler","opts","Error","Object","assign","viewport","modTop","modRight","modBottom","modLeft","threshold","Array","isArray","thresholdArray","map","t","Math","floor","minThreshold","min","intersectionObserverOptions","root","Node","rootMargin","intersectionObserver","IntersectionObserver","entries","observer","entryForEl","filter","entry","unobserve","isInViewport","observe","el","Promise","resolve","reject","_","e"],"mappings":"AAkCA,SAAgBA,EACdC,EACAC,EACAC,EACAC,kDAAyB,KAmBpBH,QACG,IAAII,MAAM,8DAG6DC,OAAOC,OACpF,GAtB8B,CAG9BC,SAAU,KAGVC,OAAQ,MACRC,SAAU,MACVC,UAAW,MACXC,QAAS,MAKTC,UAAW,CAAC,IAUZT,oFAGGU,MAAMC,QAAQF,IAAqC,iBAAdA,QAClC,IAAIR,MAAM,2DAIZW,EAA2BF,MAAMC,QAAQF,GAC3CA,EAAUI,aAAIC,UAAKC,KAAKC,MAAMF,EAAI,KAAO,MACzC,CAACC,KAAKC,MAAMP,EAAYA,EAAY,IAAM,GAAK,KAE7CQ,EAAuBF,KAAKG,UAAIH,KAAGH,GAEnCO,EAAwD,CAC5DC,KAAMhB,aAAoBiB,KAAOjB,EAAW,KAC5CkB,WAAejB,MAAUC,MAAYC,MAAaC,EAClDC,UAAWG,GAoBPW,EAAuB,IAAIC,8BAjBrBC,EAAsCC,OAC1CC,EAA0BF,EAAQG,gBAAOC,UAASA,EAAMhC,SAAWA,IAAQ,GAC3EiC,oBAA+BJ,EAASI,UAAUjC,IAEpD8B,IAGFA,EAAWI,oDAAsDd,EAE7DU,EAAWI,aACbjC,EAAU6B,EAAYG,EAAWjC,GAEjCE,EAAW4B,EAAYG,EAAWjC,KAKkBsB,UAE1DI,EAAqBS,QAAQnC,qBAEhB0B,EAAqBO,UAAUjC,QAKjCkC,WACXE,EACAjC,yBAAyB,IAElB,IAAIkC,iBAASC,EAASC,OAEzBxC,EACEqC,WACCI,EAAGP,GACFA,IACAK,GAAQ,aAETE,EAAGP,GACFA,IACAK,GAAQ,IAEVnC,GAEF,MAAOsC,GACPF,EAAOE"}